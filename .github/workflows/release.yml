# Build and publish each platform to their respective registries.
# Trigger: workflow_dispatch only. Run manually with numeric version (e.g. 0.3.6, no 'v' prefix).
# The workflow replaces 0.0.0 with the release version in all package files, commits, tags, then builds/publishes from that tag.
#
# Required env vars:
#   SONATYPE_USERNAME - Maven Central Portal username
# Required secrets:
#   CARGO_REGISTRY_TOKEN - crates.io API token (from https://crates.io/settings/tokens)
#   SONATYPE_TOKEN - Maven Central Portal token (from https://central.sonatype.com/usertoken)
#   GPG_PRIVATE_KEY - GPG private key for signing (no passphrase)

name: Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Numeric version (e.g. 0.3.6, no 'v' prefix)"
        required: true
      ref:
        description: "Branch/commit to release from (default: main)"
        required: false
        default: "main"
      actually_publish:
        description: "REALLY publish (not dry-run)"
        required: false
        type: boolean
        default: false

permissions:
  id-token: write # Required for OIDC
  contents: write # Create GitHub Release, push commit and tag

concurrency:
  group: release-${{ github.event.inputs.version || 'manual' }}
  cancel-in-progress: false

env:
  IS_DRY_RUN: ${{ github.event.inputs.actually_publish != 'true' }}

jobs:
  # Replace 0.0.0 with version in package files, commit, tag, push. All other jobs checkout this tag.
  prepare-release:
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.version.outputs.tag_name }}
      version_num: ${{ steps.version.outputs.version_num }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.ref }}
          fetch-depth: 0

      - name: Set version and tag name
        id: version
        run: |
          version_num="${{ github.event.inputs.version }}"
          if ! echo "$version_num" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$'; then
            echo "::error::Version must be semantic (e.g. 0.3.6 or 1.0.0-beta.1), got: $version_num"
            exit 1
          fi
          if [ "${{ github.event.inputs.actually_publish }}" = "true" ]; then
            tag_name="v${version_num}"
          else
            tag_name="dry-run-v${version_num}-${{ github.run_id }}"
          fi
          echo "version_num=$version_num" >> "$GITHUB_OUTPUT"
          echo "tag_name=$tag_name" >> "$GITHUB_OUTPUT"

      - name: Replace 0.0.0 with version in package files
        run: |
          VERSION_NUM="${{ steps.version.outputs.version_num }}"
          for f in \
            rust/Cargo.toml \
            rust/spicedb-embedded-sys/Cargo.toml \
            node/package.json \
            node/packages/linux-x64/package.json \
            node/packages/linux-arm64/package.json \
            node/packages/darwin-arm64/package.json \
            node/packages/win32-x64/package.json \
            java/pom.xml \
            python/pyproject.toml \
            csharp/SpiceDbEmbedded.csproj \
          ; do
            sed -i "s/0\.0\.0/$VERSION_NUM/g" "$f"
          done
          # For real publish, switch main crate to depend on published spicedb-embedded-sys by version (dry run keeps path dep for cargo publish --dry-run).
          if [ "${{ github.event.inputs.actually_publish }}" = "true" ]; then
            sed -i 's|spicedb-embedded-sys = { path = "spicedb-embedded-sys" }|spicedb-embedded-sys = "'"$VERSION_NUM"'"|' rust/Cargo.toml
          fi

      - name: Update package-lock.json
        working-directory: node
        run: npm install

      - name: Commit version bump
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git diff --staged --quiet || git commit -m "chore: set release version ${{ steps.version.outputs.tag_name }}"

      - name: Create tag
        run: git tag "${{ steps.version.outputs.tag_name }}"

      - name: Push commit and tag
        run: |
          ref="${{ github.event.inputs.ref }}"
          # Use force-with-lease for branch refs so we don't overwrite if the branch advanced
          if git show-ref --verify --quiet "refs/remotes/origin/$ref" 2>/dev/null; then
            base_sha="$(git rev-parse HEAD^)"
            git push --force-with-lease="origin/$ref:$base_sha" origin HEAD:"$ref"
          else
            git push origin HEAD:"$ref"
          fi
          git push origin "${{ steps.version.outputs.tag_name }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Build shared C library per platform for packaging with C#, Node, Java, Python
  build-shared-libs:
    needs: [prepare-release]
    defaults:
      run:
        shell: bash
    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: ubuntu-latest
            rid: linux-x64
          - runner: ubuntu-24.04-arm
            rid: linux-arm64
          - runner: macos-latest
            rid: osx-arm64
          - runner: windows-latest
            rid: win-x64
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.tag_name }}
          fetch-depth: 0

      - name: Set GOCACHE (absolute path required by Go)
        run: echo "GOCACHE=$HOME/.cache/go-build" >> "$GITHUB_ENV"

      - name: "Set RID from runner (macOS: we only publish osx-arm64; Intel Mac not supported)"
        id: set_rid
        run: |
          runner="${{ matrix.runner }}"
          if [[ "$runner" == macos* ]]; then
            case "$(uname -m)" in
              x86_64) echo "::error::osx-x64 is no longer supported; use an arm64 Mac runner" ; exit 1 ;;
              *)      rid="osx-arm64" ;;
            esac
          else
            rid="${{ matrix.rid }}"
          fi
          echo "rid=$rid" >> "$GITHUB_OUTPUT"

      - uses: jdx/mise-action@v3
        with:
          install_args: "go"

      - uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('shared/c/go.sum', 'shared/c/go.mod') }}
          restore-keys: ${{ runner.os }}-go-

      # Reuse staged prebuilds when go.mod/go.sum unchanged (same key as CI; shared across branches/runs).
      - uses: actions/cache@v4
        id: prebuild-cache
        with:
          path: |
            node/prebuilds
            csharp/runtimes
            java/src/main/resources/natives
            python/src/spicedb_embedded/natives
            rust/spicedb-embedded-sys/prebuilds
          key: shared-c-prebuilds-${{ matrix.rid }}-${{ hashFiles('shared/c/go.sum', 'shared/c/go.mod') }}

      - name: Copy cached prebuilds to out
        if: steps.prebuild-cache.outputs.cache-hit == 'true'
        run: |
          rid="${{ steps.set_rid.outputs.rid }}"
          mkdir -p "out/$rid/native"
          cp -r "rust/spicedb-embedded-sys/prebuilds/$rid/"* "out/$rid/native/"

      - name: Build shared C library
        if: steps.prebuild-cache.outputs.cache-hit != 'true'
        run: mise run shared-c-build

      - name: Stage and upload shared lib
        if: steps.prebuild-cache.outputs.cache-hit != 'true'
        run: |
          mkdir -p "out/${{ steps.set_rid.outputs.rid }}/native"
          case "${{ matrix.runner }}" in
            ubuntu*) cp shared/c/libspicedb.so "out/${{ steps.set_rid.outputs.rid }}/native/" ;;
            macos*)  cp shared/c/libspicedb.dylib "out/${{ steps.set_rid.outputs.rid }}/native/" ;;
            windows*)
              cp shared/c/spicedb.dll "out/${{ steps.set_rid.outputs.rid }}/native/"
              if [ -f shared/c/spicedb.def ]; then
                cp shared/c/spicedb.def "out/${{ steps.set_rid.outputs.rid }}/native/"
              fi
              ;;
          esac

      - name: Upload shared lib
        uses: actions/upload-artifact@v4
        with:
          name: shared-lib-${{ steps.set_rid.outputs.rid }}
          path: out

  # Publish spicedb-grpc-tonic first; spicedb-embedded-sys depends on it (version from crates.io when publishing).
  publish-rust-api:
    needs: [build-shared-libs, prepare-release]
    runs-on: ubuntu-latest
    env:
      MISE_ENABLE_TOOLS: "rust,buf,protoc"
    defaults:
      run:
        shell: bash
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.tag_name }}
          fetch-depth: 0

      - uses: jdx/mise-action@v3
        with:
          install_args: "rust buf protoc"

      - name: Publish spicedb-grpc-tonic to crates.io
        run: |
          if [ "${{ env.IS_DRY_RUN }}" = "true" ]; then
            cargo publish -p spicedb-grpc-tonic --token ${{ secrets.CARGO_REGISTRY_TOKEN }} --allow-dirty --dry-run
          else
            cargo publish -p spicedb-grpc-tonic --token ${{ secrets.CARGO_REGISTRY_TOKEN }} --allow-dirty 2>&1 | tee /tmp/publish.log || true
            code=${PIPESTATUS[0]}
            if [ "$code" -ne 0 ] && grep -q "already exists on crates.io" /tmp/publish.log; then
              echo "spicedb-grpc-tonic version already on crates.io, continuing"
              exit 0
            fi
            exit "$code"
          fi

  publish-rust-sys:
    needs: [build-shared-libs, publish-rust-api, prepare-release]
    runs-on: ubuntu-latest
    env:
      MISE_ENABLE_TOOLS: "rust,buf,protoc"
    defaults:
      run:
        shell: bash
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.tag_name }}
          fetch-depth: 0

      - name: Download shared lib for this platform (linux-x64)
        uses: actions/download-artifact@v4
        with:
          name: shared-lib-linux-x64

      - name: Stage shared lib into -sys crate prebuilds for build (verify step)
        run: |
          mkdir -p "rust/spicedb-embedded-sys/prebuilds/linux-x64"
          cp -r linux-x64/native/* "rust/spicedb-embedded-sys/prebuilds/linux-x64/"
          if [ -f shared/c/spicedb.def ]; then
            cp shared/c/spicedb.def "rust/spicedb-embedded-sys/prebuilds/linux-x64/"
          fi

      - name: Package Go source into -sys crate and git add -f for publish
        run: |
          mkdir -p rust/spicedb-embedded-sys/shared
          cp -r shared/c rust/spicedb-embedded-sys/shared/
          git add -f rust/spicedb-embedded-sys/shared/
          git status rust/spicedb-embedded-sys/shared/

      - uses: jdx/mise-action@v3
        with:
          install_args: "rust buf protoc"

      - name: Publish spicedb-embedded-sys to crates.io
        run: |
          if [ "${{ env.IS_DRY_RUN }}" = "true" ]; then
            cargo publish -p spicedb-embedded-sys --token ${{ secrets.CARGO_REGISTRY_TOKEN }} --allow-dirty --dry-run
          else
            cargo publish -p spicedb-embedded-sys --token ${{ secrets.CARGO_REGISTRY_TOKEN }} --allow-dirty
          fi

  publish-rust-main:
    needs: [publish-rust-sys, prepare-release]
    runs-on: ubuntu-latest
    env:
      MISE_ENABLE_TOOLS: "rust,buf,protoc"
      VERSION_NUM: ${{ needs.prepare-release.outputs.version_num }}
    defaults:
      run:
        shell: bash
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.tag_name }}
          fetch-depth: 0

      - uses: Swatinem/rust-cache@v2
        with:
          workspaces: . -> target

      - uses: jdx/mise-action@v3
        with:
          install_args: "rust buf protoc"

      - name: Update Cargo.lock to use published spicedb-embedded-sys
        if: env.IS_DRY_RUN != 'true'
        run: cargo update -p spicedb-embedded-sys

      - name: Publish main crate to crates.io
        run: |
          if [ "${{ env.IS_DRY_RUN }}" = "true" ]; then
            cargo publish -p spicedb-embedded --token ${{ secrets.CARGO_REGISTRY_TOKEN }} --allow-dirty --dry-run
          else
            cargo publish -p spicedb-embedded --token ${{ secrets.CARGO_REGISTRY_TOKEN }} --allow-dirty
          fi
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

  publish-java:
    needs: [build-shared-libs, prepare-release]
    runs-on: ubuntu-latest
    env:
      SONATYPE_USERNAME: ${{ vars.SONATYPE_USERNAME }}
      SONATYPE_TOKEN: ${{ secrets.SONATYPE_TOKEN }}
      GPG_PASSPHRASE: ""
      VERSION_NUM: ${{ needs.prepare-release.outputs.version_num }}
    defaults:
      run:
        shell: bash
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.tag_name }}
          fetch-depth: 0

      - name: Download shared libs for all platforms
        uses: actions/download-artifact@v4
        with:
          pattern: shared-lib-*
          path: shared-libs
          merge-multiple: true

      - name: Lay out natives for classifier JARs (target/natives-layout for release profile)
        run: |
          mkdir -p java/target/natives-layout/linux-x86_64/natives/linux-x86_64 \
                   java/target/natives-layout/linux-aarch_64/natives/linux-aarch_64 \
                   java/target/natives-layout/osx-aarch_64/natives/osx-aarch_64 \
                   java/target/natives-layout/windows-x86_64/natives/windows-x86_64
          cp shared-libs/linux-x64/native/* java/target/natives-layout/linux-x86_64/natives/linux-x86_64/
          cp shared-libs/linux-arm64/native/* java/target/natives-layout/linux-aarch_64/natives/linux-aarch_64/
          cp shared-libs/osx-arm64/native/* java/target/natives-layout/osx-aarch_64/natives/osx-aarch_64/
          cp shared-libs/win-x64/native/* java/target/natives-layout/windows-x86_64/natives/windows-x86_64/
          ls -R java/target/natives-layout

      - name: Verify natives layout for classifier JARs
        run: |
          for plat in linux-x86_64 linux-aarch_64 osx-aarch_64 windows-x86_64; do
            dir="java/target/natives-layout/$plat/natives/$plat"
            count=$(find "$dir" -type f 2>/dev/null | wc -l)
            if [ "$count" -eq 0 ]; then
              echo "::error::No native files in $dir (shared-libs layout may be wrong)"
              exit 1
            fi
            echo "$plat: $count file(s)"
          done

      - uses: jdx/mise-action@v3
        with:
          install_args: "java maven"

      - uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2-

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "21"
          cache: maven
          gpg-private-key: ${{ secrets.GPG_PRIVATE_KEY }}

      - name: Configure Maven Central credentials
        run: |
          if [ -z "$SONATYPE_USERNAME" ] || [ -z "$SONATYPE_TOKEN" ]; then
            echo "::error::SONATYPE_USERNAME and SONATYPE_TOKEN secrets must be set. Create a user token at https://central.sonatype.com/usertoken and add both values as repo secrets."
            exit 1
          fi
          mkdir -p ~/.m2
          # Write actual credentials (setup-java would write ${env.VAR} literals that Maven does not expand)
          cat > ~/.m2/settings.xml << EOF
          <settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd">
            <servers>
              <server>
                <id>central</id>
                <username>${SONATYPE_USERNAME}</username>
                <password>${SONATYPE_TOKEN}</password>
              </server>
            </servers>
          </settings>
          EOF

      - name: Build Java library
        working-directory: java
        run: mvn -B -ntp compile

      - name: Prepare test classpath natives (src/main/resources/natives so Surefire uses same path as CI/local)
        run: |
          mkdir -p java/src/main/resources/natives
          cp -r java/target/natives-layout/linux-x86_64/natives/* java/src/main/resources/natives/
          cp -r java/target/natives-layout/linux-aarch_64/natives/* java/src/main/resources/natives/
          cp -r java/target/natives-layout/osx-aarch_64/natives/* java/src/main/resources/natives/
          cp -r java/target/natives-layout/windows-x86_64/natives/* java/src/main/resources/natives/
          ls -R java/src/main/resources/natives

      - name: Publish to Maven Central
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          cd java
          # Version already set in prepare-release (0.0.0 → VERSION_NUM in pom.xml). No clean: natives in target/natives-layout.
          if [ "${{ env.IS_DRY_RUN }}" = "true" ]; then
            mvn -B -ntp -P release package
            echo "Dry run: would publish Java $VERSION_NUM to Maven Central" >> "$GITHUB_STEP_SUMMARY"
          else
            mvn -B -ntp -P release package deploy
            echo "Published Java $VERSION_NUM to Maven Central (main + linux-x86_64, linux-aarch_64, osx-aarch_64, windows-x86_64 classifier JARs)" >> "$GITHUB_STEP_SUMMARY"
          fi

  publish-npm:
    needs: [publish-npm-platforms, prepare-release]
    runs-on: ubuntu-latest
    env:
      VERSION_NUM: ${{ needs.prepare-release.outputs.version_num }}
    defaults:
      run:
        shell: bash
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.tag_name }}
          fetch-depth: 0

      - uses: jdx/mise-action@v3
        with:
          install_args: "node"

      - uses: actions/cache@v4
        with:
          path: node/node_modules
          key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json', '**/package.json') }}
          restore-keys: ${{ runner.os }}-npm-

      - uses: actions/setup-node@v6
        with:
          node-version: "24"
          registry-url: "https://registry.npmjs.org"

      - name: Build Node.js package
        working-directory: node
        run: |
          npm ci
          export VERSION="$VERSION_NUM"
          node -e "
          const fs = require('fs');
          const p = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          p.optionalDependencies = {
            'spicedb-embedded-linux-x64': process.env.VERSION,
            'spicedb-embedded-linux-arm64': process.env.VERSION,
            'spicedb-embedded-darwin-arm64': process.env.VERSION,
            'spicedb-embedded-win32-x64': process.env.VERSION
          };
          fs.writeFileSync('package.json', JSON.stringify(p, null, 2) + '\n');
          "
          npm install
          npm run build

      - name: Publish to npm
        working-directory: node
        run: |
          if [ "${{ env.IS_DRY_RUN }}" = "true" ]; then
            npm publish --dry-run
          else
            npm publish
          fi

  # Publish platform-specific optional packages (only that platform's binary).
  # Bootstrap: npm trusted publisher (OIDC) can only be enabled for packages that already exist.
  # Publish each of spicedb-embedded-{linux-x64,darwin-arm64,win32-x64} once manually (e.g.
  # after a release has built shared-libs, download the artifacts, run the Prepare step locally,
  # then npm publish from each node/packages/<platform>), then add trusted publisher for each in
  # the npm dashboard so future releases can publish via OIDC.
  publish-npm-platforms:
    needs: [build-shared-libs, prepare-release]
    runs-on: ubuntu-latest
    env:
      VERSION_NUM: ${{ needs.prepare-release.outputs.version_num }}
    defaults:
      run:
        shell: bash
    strategy:
      fail-fast: false
      matrix:
        include:
          - npm_platform: linux-x64
            artifact_name: shared-lib-linux-x64
            artifact_rid: linux-x64
          - npm_platform: linux-arm64
            artifact_name: shared-lib-linux-arm64
            artifact_rid: linux-arm64
          - npm_platform: darwin-arm64
            artifact_name: shared-lib-osx-arm64
            artifact_rid: osx-arm64
          - npm_platform: win32-x64
            artifact_name: shared-lib-win-x64
            artifact_rid: win-x64
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.tag_name }}
          fetch-depth: 0

      - name: Download shared lib for this platform
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}

      - name: Prepare platform package
        run: |
          PKG_DIR="node/packages/${{ matrix.npm_platform }}"
          mkdir -p "$PKG_DIR/prebuilds/${{ matrix.npm_platform }}"
          # Artifact from upload path "out" may extract as out/<rid>/native or <rid>/native
          NATIVE_SRC="${{ matrix.artifact_rid }}/native"
          if [ ! -d "$NATIVE_SRC" ]; then
            NATIVE_SRC="out/${{ matrix.artifact_rid }}/native"
          fi
          cp "$NATIVE_SRC"/* "$PKG_DIR/prebuilds/${{ matrix.npm_platform }}/"
          # Version already set in prepare-release (0.0.0 → VERSION_NUM in these package.json files).
          ls -R "$PKG_DIR"

      - uses: actions/setup-node@v6
        with:
          node-version: "24"
          registry-url: "https://registry.npmjs.org"

      - name: Publish platform package to npm
        working-directory: node/packages/${{ matrix.npm_platform }}
        run: |
          if [ "${{ env.IS_DRY_RUN }}" = "true" ]; then
            npm publish --access public --dry-run
          else
            npm publish --access public
          fi

  publish-nuget:
    needs: [build-shared-libs, prepare-release]
    runs-on: ubuntu-latest
    env:
      VERSION_NUM: ${{ needs.prepare-release.outputs.version_num }}
    defaults:
      run:
        shell: bash
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.tag_name }}
          fetch-depth: 0

      - name: Download shared libs for all platforms
        uses: actions/download-artifact@v4
        with:
          pattern: shared-lib-*
          path: shared-libs
          merge-multiple: true

      - name: Lay out runtimes for NuGet package
        run: |
          mkdir -p csharp/runtimes
          for dir in shared-libs/*/; do
            rid=$(basename "$dir")
            mv "$dir" "csharp/runtimes/$rid"
          done
          ls -R csharp/runtimes

      - uses: jdx/mise-action@v3
        with:
          install_args: "dotnet"

      - uses: actions/cache@v4
        with:
          path: csharp/artifacts
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/bin/Release/SpiceDbEmbedded.nupkg') }}
          restore-keys: ${{ runner.os }}-nuget-

      - name: Build C# package
        run: dotnet build csharp/SpiceDbEmbedded.sln -c Release -p:Version=${{ env.VERSION_NUM }}

      - name: Build NuGet package
        working-directory: csharp
        run: dotnet pack -c Release -p:Version=${{ env.VERSION_NUM }}

      # Get a short-lived NuGet API key (skip on dry run)
      - name: NuGet login (OIDC → temp API key)
        if: env.IS_DRY_RUN != 'true'
        uses: NuGet/login@v1
        id: login
        with:
          user: ${{ vars.NUGET_USER }}

      # Push the package
      - name: NuGet push
        if: env.IS_DRY_RUN != 'true'
        working-directory: csharp
        run: dotnet nuget push bin/Release/SpiceDbEmbedded.nupkg --api-key ${{ steps.login.outputs.NUGET_API_KEY }} --source https://api.nuget.org/v3/index.json

      - name: NuGet push (dry run)
        if: env.IS_DRY_RUN == 'true'
        working-directory: csharp
        run: |
          dotnet nuget verify bin/Release/SpiceDbEmbedded.nupkg
          echo "Dry run: would push SpiceDbEmbedded.nupkg to NuGet"

  # Build platform-specific wheels with bundled native lib (one job per OS).
  build-python-wheels:
    needs: [build-shared-libs, prepare-release]
    defaults:
      run:
        shell: bash
    strategy:
      fail-fast: false
      matrix:
        include:
          - runner: ubuntu-latest
            artifact_rid: linux-x64
            natives_key: linux-x64
          - runner: ubuntu-24.04-arm
            artifact_rid: linux-arm64
            natives_key: linux-arm64
          - runner: macos-latest
            artifact_rid: osx-arm64
            natives_key: darwin-arm64
          - runner: windows-latest
            artifact_rid: win-x64
            natives_key: win32-x64
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.tag_name }}
          fetch-depth: 0

      - name: Download shared lib for this platform
        uses: actions/download-artifact@v4
        with:
          name: shared-lib-${{ matrix.artifact_rid }}

      - name: Stage native lib into package
        run: |
          mkdir -p python/src/spicedb_embedded/natives/${{ matrix.natives_key }}
          NATIVE_SRC="${{ matrix.artifact_rid }}/native"
          [ ! -d "$NATIVE_SRC" ] && NATIVE_SRC="out/${{ matrix.artifact_rid }}/native"
          cp "$NATIVE_SRC"/* python/src/spicedb_embedded/natives/${{ matrix.natives_key }}/
          ls -R python/src/spicedb_embedded/natives

      - uses: jdx/mise-action@v3
        with:
          install_args: "python"

      - name: Build Python package
        working-directory: python
        run: pip install -e .

      - name: Build wheel
        working-directory: python
        run: python -m pip install build && python -m build --wheel

      - name: Build sdist (Linux only)
        if: matrix.runner == 'ubuntu-latest'
        working-directory: python
        run: python -m build --sdist

      - name: Upload wheel
        uses: actions/upload-artifact@v4
        with:
          name: python-wheel-${{ matrix.natives_key }}
          path: python/dist/*.whl

      - name: Upload sdist
        if: matrix.runner == 'ubuntu-latest'
        uses: actions/upload-artifact@v4
        with:
          name: python-sdist
          path: python/dist/*.tar.gz

  publish-pypi:
    needs: [build-python-wheels, prepare-release]
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.tag_name }}
          fetch-depth: 0

      - name: Download all Python artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: python-*
          path: python/dist
          merge-multiple: true

      - name: Publish package distributions to PyPI
        if: env.IS_DRY_RUN != 'true'
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: python/dist

      - name: Publish to PyPI (dry run)
        if: env.IS_DRY_RUN == 'true'
        run: |
          pip install twine
          twine check python/dist/*
          echo "Dry run: would upload the following to PyPI:"
          ls -lh python/dist/*

  create-release:
    needs:
      [
        build-shared-libs,
        publish-rust-main,
        publish-java,
        publish-npm,
        publish-nuget,
        publish-pypi,
        prepare-release,
      ]
    runs-on: ubuntu-latest
    env:
      VERSION: ${{ needs.prepare-release.outputs.tag_name }}
      VERSION_NUM: ${{ needs.prepare-release.outputs.version_num }}
    defaults:
      run:
        shell: bash
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.tag_name }}
          fetch-depth: 0

      - name: Download shared libs for Rust release tarballs
        uses: actions/download-artifact@v4
        with:
          pattern: shared-lib-*
          path: shared-libs
          merge-multiple: true

      - name: Build lib tarballs for Rust crates (download at build time)
        run: |
          set -e
          for rid in linux-x64 linux-arm64 osx-arm64 win-x64; do
            src="shared-libs/${rid}/native"
            [[ ! -d "$src" ]] && src="shared-libs/out/${rid}/native"
            [[ ! -d "$src" ]] && { echo "Missing shared lib for ${rid}"; exit 1; }
            mkdir -p "rust-lib-assets/${rid}"
            cp -r "${src}/." "rust-lib-assets/${rid}/"
            (cd "rust-lib-assets/${rid}" && tar -czf "../../libspicedb-${rid}.tar.gz" .)
          done
          ls -la libspicedb-*.tar.gz

      - uses: actions/setup-node@v6
        with:
          node-version: "24"

      - name: Delete current tag locally
        run: |
          git tag -d "$VERSION" 2>/dev/null || true
          # So conventional-changelog's "latest tag" is the previous release; commits from that tag to HEAD = this release

      - name: Generate changelog
        id: changelog
        run: |
          npx conventional-changelog-cli@5 -p angular -i CHANGELOG.md -s -r 1 > changelog.md || true
          # clean_changelog: strip first "## version" line so release body doesn't duplicate the release title
          first=$(head -1 changelog.md 2>/dev/null || true)
          if [[ "$first" == "##"* ]]; then
            tail -n +2 changelog.md > clean_changelog.md
          else
            cp changelog.md clean_changelog.md
          fi
          {
            echo "changelog<<CHANGELOG_EOF"
            cat changelog.md
            echo "CHANGELOG_EOF"
            echo "clean_changelog<<CLEAN_CHANGELOG_EOF"
            cat clean_changelog.md
            echo "CLEAN_CHANGELOG_EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release (dry run)
        if: env.IS_DRY_RUN == 'true'
        run: |
          echo "Dry run: would create GitHub release ${{ env.VERSION }} with assets:"
          ls -lh libspicedb-*.tar.gz

      - name: Create GitHub Release
        if: env.IS_DRY_RUN != 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.VERSION }}
          name: ${{ env.VERSION }}
          files: |
            libspicedb-linux-x64.tar.gz
            libspicedb-linux-arm64.tar.gz
            libspicedb-osx-arm64.tar.gz
            libspicedb-win-x64.tar.gz
          body: |
            ${{ steps.changelog.outputs.clean_changelog }}

            Packages have been published to the following registries:

            | Package | Registry | Link |
            |---------|----------|------|
            | **Rust** | crates.io | [spicedb-embedded](https://crates.io/crates/spicedb-embedded) |
            | **Java** | Maven Central | [com.borkfork:spicedb-embedded](https://central.sonatype.com/artifact/com.borkfork/spicedb-embedded) |
            | **Node.js** | npm | [spicedb-embedded](https://www.npmjs.com/package/spicedb-embedded) |
            | **.NET** | NuGet | [SpiceDbEmbedded](https://www.nuget.org/packages/SpiceDbEmbedded) |
            | **Python** | PyPI | [spicedb-embedded](https://pypi.org/project/spicedb-embedded/) |

            ### Installation

            **Rust**:
            ```bash
            cargo add spicedb-embedded
            ```

            **Node.js**:
            ```bash
            npm install spicedb-embedded
            ```

            **.NET**:
            ```bash
            dotnet add package SpiceDbEmbedded
            ```

            **Python**:
            ```bash
            pip install spicedb-embedded
            ```

            **Java** (Maven). Add the main artifact and the matching classifier JAR for your platform (`linux-x86_64`, `linux-aarch_64`, `osx-aarch_64`, `windows-x86_64`):
            ```xml
            <dependency>
              <groupId>com.borkfork</groupId>
              <artifactId>spicedb-embedded</artifactId>
              <version>${{ env.VERSION_NUM }}</version>
            </dependency>
            <!-- Platform native library (use one: linux-x86_64, linux-aarch_64, osx-aarch_64, windows-x86_64) -->
            <dependency>
              <groupId>com.borkfork</groupId>
              <artifactId>spicedb-embedded</artifactId>
              <version>${{ env.VERSION_NUM }}</version>
              <classifier>linux-x86_64</classifier>
            </dependency>
            ```

            With **os-maven-plugin** you can use `${os.detected.classifier}` directly:
            ```xml
            <extensions>
              <extension>
                <groupId>kr.motd.maven</groupId>
                <artifactId>os-maven-plugin</artifactId>
                <version>1.7.1</version>
              </extension>
            </extensions>
            ```
            Then add the native dependency with `<classifier>${os.detected.classifier}</classifier>`.

            **Java** (Gradle). Add the main artifact and the classifier for your platform (`linux-x86_64`, `linux-aarch_64`, `osx-aarch_64`, or `windows-x86_64`):
            ```groovy
            implementation 'com.borkfork:spicedb-embedded:${{ env.VERSION_NUM }}'
            implementation 'com.borkfork:spicedb-embedded:${{ env.VERSION_NUM }}:linux-x86_64'  // or linux-aarch_64, osx-aarch_64, windows-x86_64
            ```
            Kotlin DSL:
            ```kotlin
            implementation("com.borkfork:spicedb-embedded:${{ env.VERSION_NUM }}")
            implementation("com.borkfork:spicedb-embedded:${{ env.VERSION_NUM }}:linux-x86_64")  // or linux-aarch_64, osx-aarch_64, windows-x86_64
            ```
            With [osdetector-gradle-plugin](https://github.com/google/osdetector-gradle-plugin) you can use the classifier dynamically:
            ```groovy
            plugins { id "com.google.osdetector" version "1.7.3" }
            dependencies {
              implementation "com.borkfork:spicedb-embedded:${{ env.VERSION_NUM }}"
              implementation "com.borkfork:spicedb-embedded:${{ env.VERSION_NUM }}:${osdetector.classifier}"
            }
            ```
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # On dry run, remove the tag and revert the version-bump commit on the branch.
  cleanup-dry-run:
    if: github.event.inputs.actually_publish != 'true'
    needs: [create-release, prepare-release]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.tag_name }}
          fetch-depth: 2

      - name: Delete tag and revert commit (dry run)
        run: |
          set -euo pipefail
          tag_name="${{ needs.prepare-release.outputs.tag_name }}"
          ref="${{ github.event.inputs.ref }}"
          git push origin --delete "$tag_name" || true
          git fetch origin "$ref" 2>/dev/null || true
          local_head="$(git rev-parse HEAD)"
          if git show-ref --verify --quiet "refs/remotes/origin/$ref" 2>/dev/null; then
            remote_head="$(git rev-parse "refs/remotes/origin/$ref")"
            if [ "$remote_head" = "$local_head" ]; then
              prev="$(git rev-parse HEAD^)"
              echo "Reverting dry-run version bump on $ref to $prev"
              git push origin "$prev:$ref"
            else
              echo "::warning::Remote $ref has moved (remote: $remote_head, our tag: $local_head); skipping branch revert to avoid losing commits."
            fi
          else
            echo "Remote ref $ref does not exist; skipping branch revert."
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
